
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Technical overview Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="development.html" />
    
    
    <link rel="prev" href="cms_usage.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="app_usage.html">
            
                <a href="app_usage.html">
            
                    
                    How to use the app
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="cms_usage.html">
            
                <a href="cms_usage.html">
            
                    
                    How to use the CMS
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4" data-path="technical_overview.html">
            
                <a href="technical_overview.html">
            
                    
                    Technical overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="development.html">
            
                <a href="development.html">
            
                    
                    Development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="deployment.html">
            
                <a href="deployment.html">
            
                    
                    Deployment
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Technical overview</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="technical-overview">Technical overview</h1>
<p>The Lifted App and CMS, which we will refer to collectively as &quot;the system&quot;,
are web apps which can be accessed through a modern web browser, both on
desktop or mobile devices. Like most web apps, the system is split into
frontend and backend code and subsystems.</p>
<h2 id="backend-architecture">Backend architecture</h2>
<p>Early in the development of the system, it was found that pre-packaged software
solutions which can meet LEC&apos;s needs do not exist. As such, the App and CMS
were tailor-made.</p>
<p><a href="images/architecture.png" target="_blank">
    <img src="images/architecture.png" width="400">
</a>
<!--![Local Image](./images/architecture.png)--></p>
<p>The backend runs on two Amazon EC2 server instances and uses Amazon CloudFront
as a content delivery network (CDN). Amazon Route 53 manages the Domain Name
Service (DNS) records of the <code>lifted.sg</code> domain, registered under <a href="https://speednames.asia/" target="_blank">Speednames
Asia</a>. All application logs (except for those of the
scraper) are fed to Amazon CloudWatch.</p>
<p><a href="images/aws_services.png" target="_blank">
    <img src="images/aws_services.png" width="200">
</a>
<!--![Local Image](./images/aws_services.png)--></p>
<p>The app and CMS servers run Docker (v17) containers orchestrated by Docker
Compose (v1.17.1), as well as one non-containerised Postgres (v9.5) instance
per server.</p>
<p>The EC2 instances use a security group as a firewall. It restricts access to
each databases to the IP addresses of each server, and opens the necessary
ports for database, HTTP and SSH access. In effect, each databases can only be
accessed from <code>localhost</code> or from the other server, and not externally. 
Furthermore, all non-whitelisted ports are blocked.</p>
<p>The system architecture is separated in this way to improve security and
reliability. As the CMS is meant for internal use only, and the App for public
use, keeping the CMS data separate prevents an entire class of bugs which might
expose it through potentially flawed App code. Moreover, having the CMS
separate allows it to be upgraded without affecting the App.</p>
<p>Docker was chosen because it greatly reduces deployment time and eliminates
many server environment inconsistencies. The goal was to make deployment as
hassle-free as possible due to the large number and complex relationships
between code dependencies in both the frontend and backend.</p>
<p>The backend web server runs Django because it is reliable, elegant, and
battle-tested. It provides very useful features, especially a powerful database
ORM, right out of the box.</p>
<p>The source code is managed via a single Git repository, and backed up in both
Github and AWS CodeCommit. The source code is organised in the following
manner. Deployment-related code is confined to the <code>docker</code> and <code>scripts</code>
directories, while source code for the system mainly resides in <code>src</code>. Note
that some directories, such as those for Django templates or migrations are
excluded below as it is only a general overview or the organisation of the
code.</p>
<pre><code>admin_server
    |- scraper/
docker
    |- admin_server
        |- Docker, Docker Compose, and configuration files
    |- app_server
        |- Ditto
docs (this Gitbook)
license_extractor (see below)
scripts (deployment scripts)
    |- admin_server
        | dev
        | prod
    |- app_server
        | dev
        | prod
src
    |- lib (TODO: shift to a more suitable location
    |- lm (the Django project directory)
        |- app
            |- frontend
        |- cms
            |- frontend
        |- static
</code></pre><h3 id="the-docker-containers">The Docker containers</h3>
<p>The Docker containers run Alpine Linux to reduce image size, minimise attack
surfaces, and simplify development. The small image size benefit can be most
acutely experienced when deploying the system, a process that involves using
<code>docker push</code> to copy Docker images to the remote servers. If the images were
to use Ubuntu or even Debian images, this process would take up more than twice
the amount of time and bandwidth.</p>
<p>On the CMS server, Docker Compose orchestrates the following containers via
<code>docker/admin_server/docker-compose.prod.yml</code>:</p>
<ul>
<li><p><strong>admin_cms</strong></p>
<ul>
<li>Defined in <code>docker/admin_server/cms.prod.dockerfile</code>.</li>
<li>Runs Gunicorn and Nginx to serve the Django project located at <code>src/lm</code>.
More information about this Django project can be found below.</li>
<li>Configuration files:<ul>
<li><code>docker/admin_server/nginx.conf</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>admin_scrapyd</strong></p>
<ul>
<li>Defined in <code>docker/admin_server/scrapyd.prod.dockerfile</code>.</li>
<li>Using <code>supervisord</code>, the container runs <code>scrapyd</code>, which is in turn
configured to control a Scrapy project whose code is located in
<code>admin_server/scraper/</code>.</li>
<li><code>supervisord</code> is necessary in order to schedule scrape jobs and run the
<code>scrapyd</code> daemon in the background. However, note that the scrape job
scheduler at <code>scraper_scheduler.py</code> is disabled as the Lifted team prefers to
launch the jobs manually.</li>
<li>Configuration files:<ul>
<li><code>docker/admin_server/scrapyd.conf</code></li>
<li><code>docker/admin_server/supervisor_scrapyd.ini</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>admin_db</strong></p>
<ul>
<li>Defined in <code>docker/admin_server/db.prod.dockerfile</code>.</li>
<li>Only useful when running the CMS on a machine that does not have a local
copy of Postgres, such as a development machine. On a production machine,
do not configure <code>admin_cms</code> to connect to this container, and use a
non-Dockerised Postgres database instead. If you do this, <code>admin_db</code> can
be left alone.</li>
<li>Configuration files:<ul>
<li><code>./docker/app_server/db.init.sql</code>: creates a database called
<code>admin</code> and grants access privileges to the <code>postgres</code> user.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>On the App server, the following containers, orchestrated via
<code>docker/app_server/docker-compose.prod.yml</code>, are:</p>
<ul>
<li><p><strong>liftedmobile</strong></p>
<ul>
<li>Defined in <code>docker/app_server/liftedmobile.prod.dockerfile</code></li>
<li>Like <code>admin_cms</code>, this container runs Gunicorn and Nginx to serve
the Django project at <code>src/lm</code>.</li>
<li>Configuration files:<ul>
<li><code>docker/app_server/nginx.conf</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>liftedmobile_tlsproxy</strong></p>
<ul>
<li>Defined in <code>docker/app_server/tlsproxy.prod.dockerfile</code></li>
<li>All traffic to the <strong>liftedmobile</strong> container passes through this
container, which is an Nginx reverse proxy running on an <code>nginx:alpine</code>
image.</li>
<li>This image is intended to provide easy TLS configuration for the App
using Let&apos;s Encrypt. At the moment, CloudFront provides SSL/TLS
protection, and the link between CloudFront and EC2 is not protected by
TLS. This will be rectified, but is an acceptable compromise because
said link is internal to the AWS network.</li>
<li>Configuration files:<ul>
<li><code>docker/app_server/nginx.conf.tlsproxy</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>liftedmobile_db</strong></p>
<ul>
<li>Defined in <code>docker/app_server/db.prod.dockerfile</code></li>
<li>Configuration files:<ul>
<li><code>./docker/app_server/db.init.sql</code>: creates a database called
<code>liftedmobile</code> and grants access privileges to the <code>postgres</code> user.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="the-waitforpostgrespy-script">The <code>wait_for_postgres.py</code> script</h4>
<p><code>wait_for_postgres.py</code> reads Django&apos;s <code>settings.py</code> for information about how
to connect to the database so that it can run the <code>pg_isready</code> command at
regular intervals until it exits successfully.  Each <code>CMD</code> directive in the
<code>liftedmobile</code> and <code>admin_cms</code> Dockerfiles execute this script to ensure that
their corresponding web server launches after the database is ready. Otherwise,
the web servers will not start up reliably.</p>
<h3 id="the-django-project">The Django project</h3>
<p>Both the App and CMS run the same Django project code located at <code>src/lm</code>.</p>
<p>This project contains two apps: <code>cms</code> and <code>app</code>. Only the CMS server runs <code>cms</code>
and <code>app</code>, while the App server only runs <code>app</code>. This is possible because the
<code>admin_cms</code> container is configured by Docker Compose to have the environment
variable <code>CMS</code> set to <code>true</code> via <code>docker/admin_server/docker-compose.prod.yml</code>.
The code in <code>src/lm/lm/settings.py</code> checks whether this environment variable
exists, and if it does, it enables the <code>cms</code> app as an installed app:</p>
<pre><code class="lang-python"><span class="hljs-keyword">if</span> <span class="hljs-string">&apos;CMS&apos;</span> <span class="hljs-keyword">in</span> os.environ:
    INSTALLED_APPS.append(<span class="hljs-string">&quot;cms&quot;</span>)
</code></pre>
<p>This means that even though the App server contains code for both <code>app</code> and
<code>cms</code>, including each of their views and URL routes, but because Docker Compose
sets the <code>CMS</code> environment variable, only the CMS server will enable the <code>cms</code>
Django app. </p>
<p>In effect, since the CMS server runs <em>both</em> the <code>app</code> and <code>cms</code> Django
applications, it is a mirror of what the App server does.</p>
<table>
<thead>
<tr>
<th></th>
<th><code>app</code></th>
<th><code>cms</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>App server</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>CMS server</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p>To make it obvious to a CMS user that they are accessing the CMS, the App will
insert a banner with a link to the CMS dashboard if it detects the <code>CMS</code>
environment variable. The link to the CMS is not hardcoded into the App
frontend code, but dynamically inserted in the base template in Django
(<code>src/lm/app/templates/app/base.html</code>).</p>
<p>Note, however, that all the routes in the CMS server are password-protected,
including those from <code>app</code>. This is made possible by <code>src/lm/app/views.py</code>
which applies a Python decorator (<code>conditional_decorate</code>) to every view. Each
decorator checks whether the <code>CMS</code> environment variable exists, and if it does,
applies the <code>staff_member_required</code> decorator from the
<code>django.contrib.admin.views.decorators</code> library, effectively restricting App
functionality in the CMS to only staff, but not applying said restrictions in
the App (since it does not have the <code>CMS</code> environment variable set.</p>
<p><code>settings.py</code> also looks for the <code>CMS</code> environment variable to selectively
modify or add the following configuration settings <strong>in production</strong> as such:</p>
<ul>
<li><code>SCRAPYD_IP</code>: the internal IP address of the <code>admin_scrapyd</code> container</li>
<li><code>SESSION_COOKIE_NAME</code>: the Django session cookie name. This setting is
modified to prevent a cookie namespace clash with <code>app</code>.</li>
<li><code>SECRET_KEY</code>: the Django secret key will be read from
<code>/run/secrets/django_secret</code></li>
<li><code>SERVER_EMAIL</code>: deprecated and should be removed</li>
<li><code>CMS_TEMP_SUPER_USERNAME</code>: the username of the CMS administrator</li>
<li><code>CMS_TEMP_SUPER_PASSWORD</code>: reads the CMS administrator&apos;s password from
<code>/run/secrets/cms_admin_pwd</code></li>
<li><code>SCRAPYD_API_KEY</code>: reads a secret key from <code>/run/secrets/scrapyd_api_key</code> for
authentication between the <code>admin_scrapyd</code> container and the <code>admin_cms</code> server.
More information about interaction between these two containers can be found in
the section about the scraper.</li>
<li><code>LOGIN_REDIRECT_URL</code>: ensures that after a successful login ,the Django
authentication system will redirect the user to <code>/cms</code>.</li>
<li><code>TEMPLATES</code>: adds the <code>export_vars</code> function defined in
<code>src/lm/cms/context_processors.py</code> as a template context processor. This
allows the <code>src/lm/cms/templates/cms/base.html</code> template to access the <code>DEV</code>
environment variable and thereby selectively load static assets from the
<code>preact watch</code> server in development, or from <code>/static</code> in production. More
information about the development environment can be found in the
<a href="development.html">Development</a> section.</li>
</ul>
<h3 id="ports-used">Ports used</h3>
<table>
<thead>
<tr>
<th>Number</th>
<th>Service</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>80</td>
<td>HTTP</td>
<td></td>
</tr>
<tr>
<td>443</td>
<td>SSL/TLS</td>
<td></td>
</tr>
<tr>
<td>2233</td>
<td>SSH</td>
<td>It is a best practice to not use port 22 for SSH</td>
</tr>
<tr>
<td>5544</td>
<td>Postgres</td>
<td>Restricted to traffic between the App and CMS servers</td>
</tr>
<tr>
<td>9001</td>
<td>HTTP</td>
<td>For the CMS</td>
</tr>
</tbody>
</table>
<h3 id="the-app-and-cms-databases">The App and CMS databases</h3>
<p><a href="images/db_separation.png" target="_blank">
    <img src="images/db_separation.png" width="400">
</a></p>
<p>As mentioned above, the same Django project runs on both the App and CMS
servers. It is crucial to note that data is not replicated between each
corresponding database. The CMS server does not store <code>app</code> data, and the App
server does not store <code>cms</code> data. Only the App server stores <code>app</code> data, and
only the CMS stores <code>cms</code> data. This is achieved by the following technique:</p>
<ol>
<li><code>settings.py</code> appends <code>&quot;cms.db_routers.CmsRouter&quot;</code> to the <code>DATABASE_ROUTERS</code>
configuration setting if and only if <code>CMS</code> is an environment variable.</li>
<li>The <code>DATABASES</code> configuration setting in <code>settings.py</code> differs for the CMS
and App servers, again depending on the presence of the <code>CMS</code> environment
variable.<ul>
<li>In the App, there is only 1 database configured: <code>default</code>.</li>
<li>In the CMS, there are 2 databases configured:<ol>
<li><code>app_server</code>, which points to the database on the remote App server</li>
<li><code>default</code>, which points to CMS database, which should be set to <code>dockerhost</code> (more on this below)</li>
</ol>
</li>
</ul>
</li>
<li><code>CmsRouter</code>, defined in <code>src/lm/cms/db_routers.py</code>, uses the <code>db_for_read</code>,
<code>db_for_write</code>, and <code>allow_migrate</code> functions to tell Django which database
 to read or write to, and to disable migrations on the App database from the
 CMS server, based on the <code>app_label</code> and <code>db</code> variables. See the Django
 documentation on <a href="https://docs.djangoproject.com/en/2.0/topics/db/multi-db/" target="_blank">Multiple
 Databases</a> for more
information.</li>
</ol>
<h4 id="the-dockerhost-hostname">The <code>dockerhost</code> hostname</h4>
<p>While it is a best practice to <em>not</em> Dockerise a production database, this
creates the challenge of connecting a Docker container, which resides within
a Docker bridge network, to a database server which resides on a different
network. In the case of the <code>liftedmobile</code> container in the App
server, for instance, it  must communicate with the Postgres server situated on
the host. To make this possible, the <code>liftedmobile</code> container (as well as
<code>admin_cms</code>) have their <code>/etc/hosts</code> files configured as such:</p>
<p>In <code>docker/app_server/liftedmobile.prod.dockerfile</code> and
<code>docker/admin_server/cms.prod.dockerfile</code>:</p>
<pre><code>CMD echo $(netstat -nr | grep &apos;^0\.0\.0\.0&apos; | awk &apos;{print $2}&apos;) dockerhost &gt;&gt; /etc/hosts
&amp;&amp; (rest of the dockerfile...)
</code></pre><p>This appends the following to the <code>/etc/hosts</code> file within each container:</p>
<pre><code>172.18.0.1 dockerhost
</code></pre><p>This makes the <code>dockerhost</code> an alias to <code>172.18.0.1</code>, which is the gateway
through which the container can access the host. Since this gateway address may
not be consistent across system reboots, the <code>echo</code> command shown above is
agnostic to the actual gateway IP address, this technique removes the need to
reconfigure the system if the gateway address changes.</p>
<h3 id="postgres-configuration">Postgres configuration</h3>
<p>In order for a Docker container to connect to the Postgres server on the host,
Postgres must also be configured to listen on the Docker gateway IP:</p>
<p>In <code>/etc/postgresql/9.5/main/postgresql.conf</code>:</p>
<pre><code>listen_addresses = &apos;localhost,172.17.0.1,172.18.0.1&apos;
</code></pre><p>At the moment, the Lifted App and CMS deployment scripts do not automatically
add the gateway address to <code>postgresql.conf</code>, so this has to be done manually
for now. One way to get around this is to specify more than one possible
gateway address, as shown above (<code>171.17...</code> and <code>172.18...</code>).</p>
<p>Also make sure to change the port number away from the default:</p>
<pre><code>port = 5544
</code></pre><h4 id="initial-lifted-framework-data">Initial LIFTED Framework Data</h4>
<!--TODO: how initial data gets loaded -->
<h2 id="frontend-architecture">Frontend architecture</h2>
<p>The frontend is, broadly speaking, a Single-Page Application. A single
JavaScript app, developed using the Preact user interface library, LESS for
stylesheets, Webpack for module bundling, and Babel for ES2015 transpilation,
comprises the frontend code. URL routes are handled by <code>preact-router</code>.</p>
<!--TODO: how to add a new route, relationship between urls.py and preact-router -->
<h3 id="architectural-considerations">Architectural considerations</h3>
<!--TODO: why Preact?-->
<!--TODO: why preact-cli?-->
<!--TODO: static files -->
<h2 id="code-license-extractor">Code license extractor</h2>
<!--TODO -->

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="cms_usage.html" class="navigation navigation-prev " aria-label="Previous page: How to use the CMS">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="development.html" class="navigation navigation-next " aria-label="Next page: Development">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Technical overview","level":"1.4","depth":1,"next":{"title":"Development","level":"1.5","depth":1,"path":"development.md","ref":"development.md","articles":[]},"previous":{"title":"How to use the CMS","level":"1.3","depth":1,"path":"cms_usage.md","ref":"cms_usage.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"technical_overview.md","mtime":"2018-03-17T13:14:22.242Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-03-17T09:20:46.842Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

